# -*- coding: utf-8 -*-
"""Vigenere Decryption

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b3Nqnbh2A5cT-D5b4aUFKESy0l-qPiln

## Vigenere Decrypion

**Author**: Chelina Ortiz Montanez

**Class**: CS378 - Intro to Cryptology

**Prompt**: The ciphertext (you can download the file vig2.txt from the canvas) was generated using the Vigenere method with a key of length at most 6. Decrypt it. To this end build a suite of programs for breaking the Vigenere cipher.

**References**: Discussion with Masters in C.S. student Ryan Lindsey, repeating sequences and nthLetter functions from: https://inventwithpython.com/hacking/chapter21.html, frequency analysis equation from Dr. Truszczynski's notes, and Vigenere decryption algorithm from: https://www.geeksforgeeks.org/vigenere-cipher/
"""
# Please install the langdetect library
# pip install langdetect

"""## Intialization of project
** To use a different file text, upload new file and change in function call to use a different file.
"""

import itertools, string
from langdetect import detect

alphabet = 'abcdefghijklmnopqrstuvwxyz'
# Frequency of letters in the English language
charFreqEnglish = {'e': 12.70, 't': 9.06, 'a': 8.17, 'o': 7.51, 'i': 6.97,
                     'n': 6.75, 's': 6.33, 'h': 6.09, 'r': 5.99, 'd': 4.25,
                     'l': 4.03, 'c': 2.78, 'u': 2.76, 'm': 2.41, 'w': 2.36,
                     'f': 2.23, 'g': 2.02, 'y': 1.97, 'p': 1.93, 'b': 1.29,
                     'v': 0.98, 'k': 0.77, 'j': 0.15, 'x': 0.15, 'q': 0.10,
                     'z': 0.07}
ciphertext = open('vig2.txt').read()

"""## Finding the key
Using Kasiski's method, we find the key used to encrypt this message
"""

## Find repeating sequences
spaceSequence = {} # list the distance between the occurences of sequence
# Loop to iterate through different length of sequences (from 3 to 6 letters)
for sLength in range(3, 7):
  # modified length of ciphertext according to the size of the sequence being
  #   tested to avoid array out of bounds error
  cipherLenSeq = len(ciphertext)-sLength
  for sStart in range(cipherLenSeq):
    # add sequence of sLength to array
    sequence = ciphertext[sStart:sStart + sLength]
    # look for occurrences of sequence in the rest of ciphertext
    for i in range(sStart + sLength, cipherLenSeq):
      if ciphertext[i:i + sLength] == sequence:
        if sequence not in spaceSequence:
          spaceSequence[sequence] = [] # spaceSequence: Spaces between subsequen
        spaceSequence[sequence].append(i-sStart) # list space between ocurrence
print(spaceSequence)
# From observing the results, I concluded that the length of the key is likely
#   to be 4, based on the fact that the factors of the repeating subsequence
#   of length 4 are also factors of 2 and 4
possibleKeyLength = 4

## Function to calculate the frequency of a character in the ciphertext
def frequencyAnalysis(cipherSubstring):
  # map in which the keys are characters and their values are their frequency in
  #   a string
  charFreqCipher = {'a': 0, 'b': 0, 'c': 0, 'd': 0, 'e': 0, 'f': 0, 'g': 0,
                    'h': 0, 'i': 0, 'j': 0, 'k': 0, 'l': 0, 'm': 0, 'n': 0,
                    'o': 0, 'p': 0, 'q': 0, 'r': 0, 's': 0, 't': 0, 'u': 0,
                    'v': 0, 'w': 0, 'x': 0, 'y': 0, 'z':0}
  for character in cipherSubstring: # count frequency of characters in string
    charFreqCipher[character] += 1

  maxVal = 0
  maxK = ''
  # Applying the frequency analysis function to a string in order to find a key
  # Function: for i = 0...26, sum += q_i * p_(i+k mod 26) where q is the
  #   frequency of letters in English and p is the frequency of letters in the
  #   string. The value of k (k=0...26) that maximizes the summation is part of
  #   key.
  for k in range(0, 26):
    sumVal = 0
    for i in range(0, 26):
      sumVal += charFreqEnglish[alphabet[i]] * charFreqCipher[alphabet[(i+k)%26]]
    if sumVal > maxVal: # check if the value of k maximizes the summation
      maxVal = sumVal
      maxK = alphabet[k] # save the value of k as a character
  return maxK

## Function to create a substring of a text which appends the nth value to a str
def nthLetter(n, keyLength, message):
  nthLetters = []
  while n < len(message):
    nthLetters.append(message[n])
    n += int(keyLength)
  return ''.join(nthLetters)

# Break up ciphertext in chunks of size the possible length of the key and using
#   Frequency Analysis, find the key
possibleKey = ""
for n in range(0, possibleKeyLength):
  nthSubstring = nthLetter(n, possibleKeyLength, ciphertext)
  nthKeyVal = frequencyAnalysis(nthSubstring)
  possibleKey += str(nthKeyVal)
print(possibleKey)

"""## Vigenere Decryption
Using the equation of Vigenere cipher: D_i = (E_i - K_i + 26) mod 26
"""

# repeat the key for the length of the ciphertext
if len(ciphertext) % len(possibleKey) != 0:
  currKey = int(len(ciphertext) / len(possibleKey)) * possibleKey + possibleKey[: len(ciphertext) % len(possibleKey)]
else:
  currKey = int(len(ciphertext) / len(possibleKey)) * possibleKey

## Test key and store decryption if the plain text is written on English
plain = ""
for i in range(len(ciphertext)):
  p = (ord(ciphertext[i])-ord(currKey[i]) + 26) % 26
  p += ord('a')
  plain += chr(p)
if detect(plain) == 'en':
  print(plain)
